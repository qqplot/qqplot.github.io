---
layout: post
title:  "컴퓨터가 실수를 표현하는 방식, 부동 소수점"
categories: [ python ]
tags: [ basic ]
fullview: false
comments: true
---


*컴퓨터가 실수를 표현하는 방식에 대해서 알아보자.*

---
<br/>

### 컴퓨터가 정보를 저장하는 방식

컴퓨터의 메모리는 0과 1, 다시 말해 2진수로만 저장이 가능하다. 그런데 사람들이 편한 표기 방법은 다양하다. 예를 들어, 숫자는 2진수보다는 10진수로 표현하는 것이 편하고 숫자로만 정보를 파악하기 보다는 문자로도 정보를 표기해야 한다. 그러나 컴퓨터에 정보를 저장하는 방식은 무조건 0과 1로만 해야 한다. 이럴 경우 어떻게 정보를 표현할 것인가? 같은 이진수라고 해도 읽는 방법을 달리 하면 된다.

<br/>

![img](https://t1.daumcdn.net/cfile/tistory/99A6A03359A668E92E)

이것이 우리가 변수를 선언할 때에 자료형과 같이 선언하는 이유이다. 흔히 쓰는 `int`는 4바이트이다. 총 32비트이므로 표현할 수 있는 숫자는 2^32가 될 것이다. (실제로는 음수를 표현하기 위해서 1비트를 signed 표시에 사용하긴 한다.)

<br/>

![img](https://t1.daumcdn.net/cfile/tistory/99918C3359A6620D0A)
- S : 부호 비트(양수는 0, 음수는 1)
- n : 타입의 크기(단위 : bit)

<br/>

참고로 파이썬3에서는 int 자료형이 4바이트 고정은 아니다. abitrary precision으로 구현했다고 한다 [[5]](https://ahracho.github.io/posts/python/2017-05-09-python-integer-overflow/). 일정 크기까지는 28바이트를 사용하다가 할당되는 크기에 따라 동적으로 늘어난다.

![img](https://ahracho.github.io/images/python/byte_used_in_python.png)

<br/>

자 이렇듯, 숫자를 표현하는 방식은 다양하다. 저장은 0과 1로만 되어 있지만 어떻게 그것을 받아들일 것이냐에 따라서 달라지는 것이다. 그렇다면 **과연 실수는 어떻게 표현할까?** 앞선 예시처럼 정수는 2진수에서 10진수로 바꾸면 된다. 하지만 10진수의 실수는 2진수로 표현이 가능할까?

<br/><br/>

### 실수의 표현 방식

정수도 표현하는 방식이 다양했듯이 실수도 표현하는 방식이 여러 개가 있을 수 있다. 대표적으로 고정 소수점과 부동 소수점 방식이 있다.

<br/>

#### 1. 고정 소수점(fixed point)

고정 소수점 방식은 정수 부분하고 소수 부분하고 나누는 것이다. 앞에 저장된 2진수는 정수로 보고 뒤에 저장된 2진수는 소수로 보는 방식이다. 문제는 이렇게 표현하면 생각보다 표현할 수 있는 숫자의 개수가 적어진다는 것이다. 아래 그림처럼 실수를 표현하면 정수 부분만 생각해도 2^15개 밖에 표현이 되지 않는다.

![img](http://www.tcpschool.com/lectures/img_c_fixed_point.png)

<br/>

#### 2. 부동 소수점(floating point) 

그래서 소수점을 일정 길이로 고정해놓는 것이 아니라 유동적으로 바꿀 수 있는 부동 소수점 방식이 대부분 사용된다. 특히 현재 사용되고 있는 부동 소수점 방식은 대부분 IEEE 754 표준을 따르고 있다[1].

- 32비트(4바이트)의 float형 실수
![img](http://www.tcpschool.com/lectures/img_c_floating_point_32.png)

<br/>

부동 소수점 방식은 지수부와 가수부를 나누는 것이다. 예를 들어, pi를 표현할 때에 3.141592... 이 아니라 3.141592 = 0.3141592 * 10 이런 식으로 표현할 수 있다. 뒤에 곱해지는 10^1 이 지수부 1이 될 것이며 3141592가 가수부가 될 것이다. 그런데 이 예시는 10진수일 때이고 2진수로는 다르게 표현된다.

<br/>

예를 들어, -3.375 라는 값을 저장한다고 해보자.

1) 2진수 변환을 한다.
`(3) + (0.375) = 0b11 + 0b0.011 = 0b11.011`
(참고) `0.375 = 0.5(1/2) * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011`

<br/>

2) 정규화 
`0b11.011 = 0b1.1011 + 2^1 (0b10)`
이는 1(부호) 1(지수) 1011(유효숫자)로 이루어져 있다.
(단, 지수는 unsigned byte라고 가정하고 숫자 +127 만들어줌)

<br/>

#### 부동 소수점 방식의 오차

이처럼 부동 소수점 방식을 사용하면 고정 소수점 방식보다 훨씬 더 많은 범위까지 표현할 수 있는 장점이 있다. 하지만 부동 소수점 방식에 의한 실수의 표현은 항상 오차가 존재한다는 단점을 가지고 있다.

<br/>

```python
sum([0.1] * 10) == 1.0
# False
```

<br/>

위의 코드를 살펴보자. 0.1을 10개로 만든 다음에 더한 값하고 1.0을 비교한다. 당연히 0.1 * 10은 1이니까 같은 값일 거라고 예상할 수 있다. 하지만 그 결과는 `False`이다. 0.1이 2진수로 표현되면서 근사값이 할당되었기 때문이다. 

프로그래밍할 때 부동소수점은 항상 '근사값'이라는 것을 기억해야 한다. 특히 수가 커질수록 오차 범위도 매우 커진다. 또한 실수 2개를 `==` 연산자로 비교하는 것은 지양해야 한다. 근사값이기 때문이다.

물론 부동 소수점 수를 지나치게 경계할 필요는 없다! 파이썬 float 연산의 에러는 부동 소수점 하드웨어에서 상속된 것이고, 대부분 기계에서는 연산당 2**53분의 1을 넘지 않는 규모이기 때문이다[2]. 이는 대부분 작업에서 필요한 수준 이상이다. 하지만 10진수 연산이 아니기 때문에 모든 float 연산은 반올림 에러가 발생할 수 있다는 점을 명심해야 한다.

<br/><br/>

### 참고
- [1] [부동 소수점 수](http://www.tcpschool.com/cpp/cpp_datatype_floatingPointNumber)
- [2] [15. 부동 소수점 산술: 문제점 및 한계](https://docs.python.org/ko/3/tutorial/floatingpoint.html)
- [3] [나무위키: 컴퓨터에서의 수 표현](https://namu.wiki/w/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%97%90%EC%84%9C%EC%9D%98%20%EC%88%98%20%ED%91%9C%ED%98%84)
- [4] [[Java] 정수형(byte, short, int, long) 정리](https://stepbystep1.tistory.com/23)
- [5] [[기초 파이썬] 파이썬 3에는 오버플로우가 없다?](https://ahracho.github.io/posts/python/2017-05-09-python-integer-overflow/)